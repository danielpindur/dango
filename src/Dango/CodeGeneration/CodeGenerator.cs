using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Dango.Analysis;
using Dango.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Dango.CodeGeneration;

internal static class CodeGenerator
{
    public static void GenerateSources(
        SourceProductionContext context,
        Compilation compilation,
        Dictionary<INamedTypeSymbol, Dictionary<EnumPair, EnumMapping>> enumMappingsBySourceEnum)
    {
        var assemblyName = compilation.AssemblyName!;

        foreach (var enumMappingsWithSourceEnum in enumMappingsBySourceEnum)
        {
            var sourceEnum = enumMappingsWithSourceEnum.Key;

            var className = NamingHelper.GenerateExtensionsClassName(sourceEnum);
            var compilationUnit = GenerateCompilationUnit(
                className, assemblyName, enumMappingsWithSourceEnum.Value, context);

            var code = compilationUnit.NormalizeWhitespace().ToFullString();

            context.AddSource($"{className}.g.cs", code);
        }
    }

    private static CompilationUnitSyntax GenerateCompilationUnit(
        string className, 
        string assemblyName,
        IEnumerable<KeyValuePair<EnumPair, EnumMapping>> mappingsForEnumPairs, 
        SourceProductionContext context)
    {
        var methods = new List<MemberDeclarationSyntax>();

        foreach (var mappingsForEnumPair in mappingsForEnumPairs)
        {
            var enumPair = mappingsForEnumPair.Key;
            var enumMapping = mappingsForEnumPair.Value;

            var sourceToDestinationValueMappings = MappingResolver.ResolveValueMappings(context, enumPair, enumMapping);

            methods.Add(GenerateNonNullableExtensionMethod(enumPair, sourceToDestinationValueMappings));
            methods.Add(GenerateNullableExtensionMethod(enumPair));
        }

        var classDeclaration = ClassDeclaration(className)
            .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
            .AddMembers(methods.ToArray());

        var namespaceDeclaration = NamespaceDeclaration(ParseName($"{assemblyName}.Generated.Dango.Mappings"))
            .AddMembers(classDeclaration);

        return CompilationUnit()
            .AddMembers(namespaceDeclaration)
            .WithLeadingTrivia(
                Comment("// <auto-generated>"), EndOfLine("\n"),
                Comment("// This code was generated by Dango tool. Do not change manually as changes will be overwritten."), EndOfLine("\n"), 
                Comment("// </auto-generated>"), EndOfLine("\n"));
    }

    private static MethodDeclarationSyntax GenerateNonNullableExtensionMethod(
        EnumPair enumPair,
        IEnumerable<(string SourceValue, string DestinationValue)> mappings)
    {
        var mappingMethodName = NamingHelper.GenerateExtensionMethodName(enumPair.SourceEnum, enumPair.DestinationEnum);

        var sourceTypeName = ParseTypeName(enumPair.SourceEnum.ToDisplayString());
        var destinationTypeName = ParseTypeName(enumPair.DestinationEnum.ToDisplayString());

        var switchArms = mappings.Select(m => GenerateSwitchArm(enumPair, m)).ToArray();

        var switchExpression = SwitchExpression(IdentifierName("value")).AddArms(switchArms);

        return MethodDeclaration(destinationTypeName, mappingMethodName)
            .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
            .AddParameterListParameters(Parameter(Identifier("value"))
                .WithType(sourceTypeName)
                .AddModifiers(Token(SyntaxKind.ThisKeyword)))
            .WithExpressionBody(ArrowExpressionClause(switchExpression))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static SwitchExpressionArmSyntax GenerateSwitchArm(
        EnumPair enumPair,
        (string SourceValue, string DestinationValue) mapping)
    {
        var sourcePattern = ConstantPattern(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
            ParseTypeName(enumPair.SourceEnum.ToDisplayString()), IdentifierName(mapping.SourceValue)));

        var destinationExpression = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
            ParseTypeName(enumPair.DestinationEnum.ToDisplayString()), IdentifierName(mapping.DestinationValue));

        return SwitchExpressionArm(sourcePattern, destinationExpression);
    }

    private static MethodDeclarationSyntax GenerateNullableExtensionMethod(EnumPair enumPair)
    {
        var mappingMethodName = NamingHelper.GenerateExtensionMethodName(enumPair.SourceEnum, enumPair.DestinationEnum);

        var sourceTypeName = NullableType(ParseTypeName(enumPair.SourceEnum.ToDisplayString()));
        var destinationTypeName = NullableType(ParseTypeName(enumPair.DestinationEnum.ToDisplayString()));

        var condition = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            IdentifierName("value"),
            IdentifierName("HasValue"));

        var returnStatement = ReturnStatement(
            InvocationExpression(IdentifierName(mappingMethodName))
                .AddArgumentListArguments(Argument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("value"), IdentifierName("Value")))));

        var ifStatement = IfStatement(condition, Block(returnStatement));

        var nullReturn = ReturnStatement(CastExpression(ParseTypeName(enumPair.DestinationEnum.ToDisplayString()),
            LiteralExpression(SyntaxKind.NullLiteralExpression)));

        return MethodDeclaration(destinationTypeName, mappingMethodName)
            .AddModifiers(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword))
            .AddParameterListParameters(Parameter(Identifier("value"))
                .WithType(sourceTypeName)
                .AddModifiers(Token(SyntaxKind.ThisKeyword)))
            .WithBody(Block(ifStatement, nullReturn));
    }
}