using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Tofu.Abstractions;

namespace Tofu;

[Generator(LanguageNames.CSharp)]
public sealed class TofuGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                static (ctx, _) => (ClassDeclarationSyntax)ctx.Node);

        var compilationAndCandidates = context.CompilationProvider.Combine(candidates.Collect());

        context.RegisterSourceOutput(compilationAndCandidates, Execute);
    }

    private static void Execute(
        SourceProductionContext context,
        (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> candidates) input)
    {
        var (compilation, candidates) = input;
        var registrarInterface = compilation.GetTypeByMetadataName(typeof(ITofuMapperRegistrar).FullName!);

        if (registrarInterface is null)
        {
            return;
        }
        
        foreach (var cls in candidates)
        {
            var model = compilation.GetSemanticModel(cls.SyntaxTree);
            if (model.GetDeclaredSymbol(cls) is not INamedTypeSymbol symbol)
            {
                continue;
            }

            if (!symbol.AllInterfaces.Contains(registrarInterface, SymbolEqualityComparer.Default))
            {
                continue;
            }

            var registerMethod = symbol.GetMembers(nameof(ITofuMapperRegistrar.Register))
                .OfType<IMethodSymbol>()
                .FirstOrDefault(m => m.Parameters.Length == 1);

            if (registerMethod is null)
            {
                continue;
            }

            var mappingInfo = AnalyzeMappings(registerMethod, model);
            var generated = GenerateCode(mappingInfo);
            context.AddSource($"{symbol.Name}Extensions.g.cs", generated);
        }
    }

    private static IEnumerable<EnumMapping> AnalyzeMappings(IMethodSymbol registerMethod, SemanticModel model)
    {
        var syntax = registerMethod.DeclaringSyntaxReferences.First().GetSyntax();
        var invocations = syntax.DescendantNodes().OfType<InvocationExpressionSyntax>();

        foreach (var invocation in invocations)
        {
            var symbolInfo = model.GetSymbolInfo(invocation);
            if (symbolInfo.Symbol is not IMethodSymbol { Name: "Enum" } method)
            {
                continue;
            }

            if (method.TypeArguments.Length != 2)
            {
                continue;
            }

            if (method.TypeArguments[0] is not INamedTypeSymbol sourceEnum ||
                method.TypeArguments[1] is not INamedTypeSymbol destinationEnum)
            {
                continue;
            }

            yield return new EnumMapping(sourceEnum, destinationEnum);
        }
    }

    private static string GenerateCode(IEnumerable<EnumMapping> mappings)
    {
        // TODO: Change to use Roslyn syntax factory API
        
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("namespace Tofu.Generated;");
        sb.AppendLine("public static partial class TofuEnumExtensions");
        sb.AppendLine("{");

        foreach (var mapping in mappings)
        {
            sb.AppendLine($$"""
                public static {{mapping.DestinationEnum.ToDisplayString()}} To{{mapping.DestinationEnum.Name}}(this {{mapping.SourceEnum.ToDisplayString()}} value) =>
                    value switch
                    {
                        _ => throw new System.ArgumentOutOfRangeException(nameof(value), value, "Unmapped enum value")
                    };
                """);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private class EnumMapping
    {
        public EnumMapping(INamedTypeSymbol sourceEnum, INamedTypeSymbol destinationEnum)
        {
            SourceEnum = sourceEnum;
            DestinationEnum = destinationEnum;
        }

        public INamedTypeSymbol SourceEnum { get; }
    
        public INamedTypeSymbol DestinationEnum { get; }

        public List<ValueMapping> Overrides { get; } = new();
    }

    private class ValueMapping
    {
        public ValueMapping(string sourceValue, string destinationValue)
        {
            SourceValue = sourceValue;
            DestinationValue = destinationValue;
        }

        public string SourceValue { get; }
    
        public string DestinationValue { get; }
    }
}